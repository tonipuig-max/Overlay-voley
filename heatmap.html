<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pista 3D – OBS (3 zonas por campo) · Firebase</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Barlow+Condensed:wght@600;700;800;900&family=Inter:wght@600;700&display=swap" rel="stylesheet">
<style>
  :root{
    /* Court palette (NO TOCAR la pista) */
    --court-top:#669FEB; --court-mid:#669FEB; --court-bot:#669FEB;
    --heat-low:#22C55E;  --heat-mid:#F59E0B;  --heat-high:#DC2626;
    --line:#ffffff;

    /* Look & feel (sin iconos ni HUDs) */
    --fivb-accent:#0EA5FF;       /* azul para trazos sutiles */
    --fivb-ink:#EAF6FF;          /* texto claro */
    --fivb-bg:rgba(10,12,16,0.82);/* panel translúcido */
    --fivb-stroke:rgba(14,165,255,0.35);

    --font-head:'Barlow Condensed', Inter, system-ui, Arial, sans-serif;
    --font-ui:'Inter', system-ui, Arial, sans-serif;
  }
  html,body{margin:0;height:100%;background:transparent}
  body{font-family:var(--font-ui);}
  .stage{position:fixed; inset:0; overflow:hidden; background:transparent}
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block; background:transparent}
</style>
</head>
<body>
  <div class="stage"><canvas id="court"></canvas></div>

<script type="module">
/***** Parámetros URL *****/
const p = new URLSearchParams(location.search);
const MATCH_ID   = p.get('matchId') || 'Ariadna2';
let   urlSet     = p.get('set');                 // si está, fuerza set
let   currentSet = urlSet ? Number(urlSet) : 0;  // 0 => seguir Firebase
const SWAP_SIDES = (p.get('swapSides')==='1');
const TEAM_HOME_URL = p.get('teamHome') || p.get('home') || '';
const TEAM_AWAY_URL = p.get('teamAway') || p.get('away') || '';

/***** Contenedor y tipografías *****/
const FRAME_PAD       = Number(p.get('framePad')||24);
const FRAME_PAD_SHORT = Number(p.get('framePadShort')||100);
const FRAME_RADIUS    = Number(p.get('frameRadius')||18);
const FRAME_FILL      = p.get('frameFill')   || getComputedStyle(document.documentElement).getPropertyValue('--fivb-bg') || 'rgba(10,12,16,0.82)';
const FRAME_STROKE    = p.get('frameStroke') || getComputedStyle(document.documentElement).getPropertyValue('--fivb-stroke') || 'rgba(14,165,255,0.35)';

const TEAM_FS       = Number(p.get('teamFS')||26); // px
const TEAM_COLOR    = p.get('teamColor') || getComputedStyle(document.documentElement).getPropertyValue('--fivb-ink') || '#FFFFFF';
const TEAM_MARGIN   = Number(p.get('teamPad')||20);

const BANNER_FS    = Number(p.get('bannerFS')||24);
const BANNER_COLOR = p.get('bannerColor') || getComputedStyle(document.documentElement).getPropertyValue('--fivb-ink') || '#FFFFFF';
const BANNER_STROKE = Number(p.get('bannerStroke')||1.5);

/***** Animaciones *****/
let heatFade = 0;           // 0 → 1
let heatFadeStarted = false;
const HEAT_MS = Math.max(0, Number(p.get('heatMs')||800));

/***** Cámara (no se muestra HUD) *****/
let YAW_DEG=44, ELEV_DEG=30, DIST=14, FOV=55;
const FIT=true, PADPX=20;

/***** Geometría *****/
const COURT_W=18, COURT_H=9, NET_H=2.43;
const POLE_RADIUS = Number(p.get('poleRadius') || 0.10);

/***** Canvas *****/
const canvas = document.getElementById('court');
const ctx = canvas.getContext('2d');

/***** Utils de color *****/
const lerp=(a,b,t)=>a+(b-a)*t;
function hslToHex(h,s,l){s/=100;l/=100;const c=(1-Math.abs(2*l-1))*s,x=c*(1-Math.abs((h/60)%2-1)),m=l-c/2;let r=0,g=0,b=0; if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;} else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;} else if(h<300){r=x;b=c;} else {r=c;b=x;} const R=Math.round((r+m)*255).toString(16).padStart(2,'0'),G=Math.round((g+m)*255).toString(16).padStart(2,'0'),B=Math.round((b+m)*255).toString(16).padStart(2,'0'); return `#${R}${G}${B}`.toUpperCase();}
function hexToRgb(h){const x=h.startsWith('#')?h.slice(1):h, v=parseInt(x,16); if(x.length!==6||Number.isNaN(v)) return {r:0,g:0,b:0}; return {r:(v>>16)&255,g:(v>>8)&255,b:v&255};}
function darkenHex(hex, amt=0.25, alpha=1){const {r,g,b}=hexToRgb(hex); const k=Math.max(0,Math.min(1,1-amt)); return `rgba(${Math.round(r*k)},${Math.round(g*k)},${Math.round(b*k)},${alpha})`;}
function hexBlend(h1,h2,t){const a=hexToRgb(h1), b=hexToRgb(h2); const r=Math.round(lerp(a.r,b.r,t)), g=Math.round(lerp(a.g,b.g,t)), bb=Math.round(lerp(a.b,b.b,t)); return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${bb.toString(16).padStart(2,'0')}`.toUpperCase();}
function mix2(h1,h2,t,a=1){const a1=hexToRgb(h1),a2=hexToRgb(h2);const r=Math.round(lerp(a1.r,a2.r,t)),g=Math.round(lerp(a1.g,a2.g,t)),b=Math.round(lerp(a1.b,a2.b,t));return `rgba(${r},${g},${b},${a})`;}
function mixHeat(low,mid,high,t,a=0.85){if(t<=0)return mix2(low,low,0,a); if(t>=1)return mix2(high,high,0,a); return t<.5?mix2(low,mid,t/.5,a):mix2(mid,high,(t-.5)/.5,a);}

/***** Paletas (solo pista/heat; no HUD) *****/
const CURATED = [
  {name:'Teal Sand', court:{top:'#669FEB',mid:'#669FEB',bot:'#669FEB'}, heat:{low:'#22C55E',mid:'#F59E0B',high:'#DC2626'}},
];
const PALETTES=[...CURATED];
let paletteIdx = 0;
function applyPalette(pal){
  const r=document.documentElement.style;
  r.setProperty('--court-top', pal.court.top);
  r.setProperty('--court-mid', pal.court.mid);
  r.setProperty('--court-bot', pal.court.bot);
  r.setProperty('--heat-low', pal.heat.low);
  r.setProperty('--heat-mid', pal.heat.mid);
  r.setProperty('--heat-high', pal.heat.high);
}
applyPalette(PALETTES[paletteIdx]);

/***** Firebase *****/
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
import { getDatabase, ref, onValue } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js';

const firebaseConfig = {
  apiKey: 'AIzaSyA4gVcq3UerKAHcmarEPlvkVp-iS7jvDaQ',
  authDomain: 'supervolei-panel-final.firebaseapp.com',
  databaseURL: 'https://supervolei-panel-final-default-rtdb.europe-west1.firebasedatabase.app',
  projectId: 'supervolei-panel-final',
  storageBucket: 'supervolei-panel-final.firebasestorage.app',
  messagingSenderId: '993690944196',
  appId: '1:993690944196:web:1a7ea451c03201e6f6ff91'
};
initializeApp(firebaseConfig);
const auth=getAuth();
const db = getDatabase();

let heatSets = {};      // { setNo: {home:[z1,z2,z3], away:[z1,z2,z3]} }
let setNumber = 1;      // heat/setNumber
let TEAM_HOME = TEAM_HOME_URL || 'HOME'; // izquierda
let TEAM_AWAY = TEAM_AWAY_URL || 'AWAY'; // derecha

function attachDBListeners(){
  const matchPath=`matches/${MATCH_ID}`;
  onValue(ref(db, `${matchPath}/teams`), s=>{
    const v=s.val()||{};
    if (!TEAM_HOME_URL && v.home) TEAM_HOME = String(v.home).toUpperCase();
    if (!TEAM_AWAY_URL && v.away) TEAM_AWAY = String(v.away).toUpperCase();
    render();
  });
  onValue(ref(db, `${matchPath}/heat/setNumber`), s=>{ setNumber = Number(s.val()||1); render(); });
  onValue(ref(db, `${matchPath}/heat/sets`), s=>{ heatSets = s.val() || {}; render(); });
}

// Autenticación anónima (si falla, seguimos: puede leer si reglas lo permiten)
signInAnonymously(auth).then(attachDBListeners).catch(()=>attachDBListeners());

/***** Datos / agregación (3 zonas por mitad) *****/
const gridMap=[
  // Columna 1 = HOME (izquierda), Columna 2 = AWAY (derecha)
  // Ajuste pedido: intercambiar mapeo de 1ª fila 2ª columna respecto a lo anterior.
  [[1,'home'], [1,'away']],
  [[2,'home'], [2,'away']],
  [[3,'home'], [3,'away']],
];
function effectiveSet(){ return currentSet>0 ? currentSet : (setNumber||1); }
function aggregateFromFirebase(){
  const sn = effectiveSet();
  const node = heatSets?.[sn] || {home:[0,0,0], away:[0,0,0]};
  const countsHalf={home:[0,0,0], away:[0,0,0]};
  for(let z=1; z<=3; z++){
    countsHalf.home[z-1] = Number(node.home?.[z-1] || 0);
    countsHalf.away[z-1] = Number(node.away?.[z-1] || 0);
  }
  if (SWAP_SIDES){
    [countsHalf.home, countsHalf.away] = [countsHalf.away, countsHalf.home];
    if (!TEAM_HOME_URL && !TEAM_AWAY_URL){ [TEAM_HOME, TEAM_AWAY] = [TEAM_AWAY, TEAM_HOME]; }
  }
  return { setShown: sn, countsHalf };
}

/***** Proyección 3D simplificada *****/
function clamp(v,min,max){return Math.max(min,Math.min(max,v))}
function wrapDeg(d){d%=360;if(d<0)d+=360;return d}
const deg2rad=d=>d*Math.PI/180;
function eyeFromParams(){
  const yaw=deg2rad(YAW_DEG), elev=deg2rad(ELEV_DEG), r=Math.max(0.1,DIST);
  const cosE=Math.cos(elev), sinE=Math.sin(elev);
  return {x:r*cosE*Math.cos(yaw), y:r*cosE*Math.sin(yaw), z:r*sinE};
}
function lookAt(eye,target={x:0,y:0,z:0},up={x:0,y:0,z:1}){
  const sub=(a,b)=>({x:a.x-b.x,y:a.y-b.y,z:a.z-b.z});
  const cross=(a,b)=>({x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x});
  const norm=v=>{const L=Math.hypot(v.x,v.y,v.z)||1;return{x:v.x/L,y:v.y/L,z:v.z/L}};
  const zc=norm(sub(target,eye)), xc=norm(cross(zc,up)), yc=cross(xc,zc);
  return {eye, xc, yc, zc};
}
function worldToCam(p,cam){ const sub=(a,b)=>({x:a.x-b.x,y:a.y-b.y,z:a.z-b.z}); const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z; const pe=sub(p,cam.eye); return {x:dot(pe,cam.xc), y:dot(pe,cam.yc), z:dot(pe,cam.zc)}; }
function projectCam(pc,f){const inv=(pc.z<=0?1e-6:1/pc.z); return {x:pc.x*f*inv, y:pc.y*f*inv, z:pc.z};}
function computeFitFocal(cam,w,h,f0,pad){
  const corners=[{x:-COURT_W/2,y: COURT_H/2,z:0},{x: COURT_W/2,y: COURT_H/2,z:0},{x: COURT_W/2,y:-COURT_H/2,z:0},{x:-COURT_W/2,y:-COURT_H/2,z:0}].map(p=>projectCam(worldToCam(p,cam),1));
  let minX=1e9,maxX=-1e9,minY=1e9,maxY=-1e9; for(const q of corners){minX=Math.min(minX,q.x);maxX=Math.max(maxX,q.x);minY=Math.min(minY,q.y);maxY=Math.max(maxY,q.y);} 
  const halfW=(w/2-pad),halfH=(h/2-pad); const needFx=halfW/Math.max(Math.abs(minX),Math.abs(maxX)); const needFy=halfH/Math.max(Math.abs(minY),Math.abs(maxY));
  return Math.min(Math.max(1,Math.min(needFx,needFy)), f0*10)*0.98;
}

/***** Contenedor *****/
function roundedRectPath(x,y,w,h,r){
  const rr=Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}
function computeFrameFromPoly(poly, dpr){
  let minX=Infinity, maxX=-Infinity, minY=Infinity, maxY=-Infinity;
  for(const p of poly){ if(p.x<minX)minX=p.x; if(p.x>maxX)maxX=p.x; if(p.y<minY)minY=p.y; if(p.y>maxY)maxY=p.y; }
  const padX = FRAME_PAD * dpr;
  const padY = (FRAME_PAD + FRAME_PAD_SHORT) * dpr;
  const x = minX - padX;
  const y = minY - padY;
  const w = (maxX - minX) + padX*2;
  const h = (maxY - minY) + padY*2;
  return {x,y,w,h};
}
function drawContainerFrame(poly, dpr){
  const {x,y,w,h} = computeFrameFromPoly(poly, dpr);
  ctx.save();
  roundedRectPath(x,y,w,h, FRAME_RADIUS * dpr);
  ctx.fillStyle   = FRAME_FILL; ctx.fill();
  ctx.lineWidth   = 2.5 * dpr;  ctx.strokeStyle = FRAME_STROKE; ctx.stroke();
  ctx.restore();
  return {x,y,w,h};
}

/***** Pista *****/
function courtGradient(ctx,topY,botY){
  const g=ctx.createLinearGradient(0,topY,0,botY);
  const top=getComputedStyle(document.documentElement).getPropertyValue('--court-top').trim();
  const mid=getComputedStyle(document.documentElement).getPropertyValue('--court-mid').trim();
  const bot=getComputedStyle(document.documentElement).getPropertyValue('--court-bot').trim();
  g.addColorStop(0, top); g.addColorStop(0.5, mid); g.addColorStop(1, bot); return g;
}
function drawCourtPrism(cam, f, sx, sy, dpr){
  const depth=.55;
  const topWorld=[{x:-COURT_W/2,y: COURT_H/2,z:0},{x: COURT_W/2,y: COURT_H/2,z:0},{x: COURT_W/2,y:-COURT_H/2,z:0},{x:-COURT_W/2,y:-COURT_H/2,z:0}];
  const botWorld=topWorld.map(p=>({x:p.x,y:p.y,z:-depth}));
  const proj=pw=>{const pr=projectCam(worldToCam(pw,cam),f); return {x:sx+pr.x,y:sy-pr.y}};
  const topP=topWorld.map(proj), botP=botWorld.map(proj);
  const cTop = getComputedStyle(document.documentElement).getPropertyValue('--court-top').trim() || '#000000';
  const cMid = getComputedStyle(document.documentElement).getPropertyValue('--court-mid').trim() || '#000000';
  const cBot = getComputedStyle(document.documentElement).getPropertyValue('--court-bot').trim() || '#000000';
  const sideFace = darkenHex(hexBlend(cTop, cMid, 0.5), 0.30, 0.95);
  const baseFace = darkenHex(cBot, 0.55, 0.95);
  ctx.fillStyle=sideFace;
  for(let i=0;i<4;i++){
    const a=topP[i], b=topP[(i+1)%4], c=botP[(i+1)%4], d=botP[i];
    ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.lineTo(c.x,c.y); ctx.lineTo(d.x,d.y); ctx.closePath(); ctx.fill();
  }
  ctx.fillStyle=baseFace;
  ctx.beginPath(); ctx.moveTo(botP[0].x,botP[0].y); for(let i=1;i<4;i++) ctx.lineTo(botP[i].x,botP[i].y); ctx.closePath(); ctx.fill();
}
function drawCourtLines(cam,f,sx,sy,dpr){
  const drawX=X=>{const a0={x:X,y:-COURT_H/2,z:0},a1={x:X,y:COURT_H/2,z:0}; const p0=projectCam(worldToCam(a0,cam),f), p1=projectCam(worldToCam(a1,cam),f);
    ctx.lineWidth = 3*dpr; ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--line').trim()||'#fff';
    ctx.beginPath(); ctx.moveTo(sx+p0.x, sy-p0.y); ctx.lineTo(sx+p1.x, sy-p1.y); ctx.stroke(); };
  drawX(-3); drawX(0); drawX(3);
}
const NET_CLEAR = 1.0;
function drawNetWithPosts(cam,f,sx,sy,dpr){
  const BL = projectCam(worldToCam({x:0,y:-COURT_H/2,z:NET_CLEAR},cam),f),
        BR = projectCam(worldToCam({x:0,y: COURT_H/2,z:NET_CLEAR},cam),f),
        TL = projectCam(worldToCam({x:0,y:-COURT_H/2,z:NET_H},cam),f),
        TR = projectCam(worldToCam({x:0,y: COURT_H/2,z:NET_H},cam),f);
  const pts=[{x:sx+BL.x,y:sy-BL.y},{x:sx+BR.x,y:sy-BR.y},{x:sx+TR.x,y:sy-TR.y},{x:sx+TL.x,y:sy-TL.y}];
  ctx.save();
  ctx.globalAlpha=.9; ctx.fillStyle='rgba(0,0,0,.35)';
  ctx.beginPath(); ctx.moveTo(pts[0].x,pts[0].y); ctx.lineTo(pts[1].x,pts[1].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.lineTo(pts[3].x,pts[3].y); ctx.closePath(); ctx.fill();
  ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.lineWidth=1*dpr;
  const steps=12; for(let i=0;i<=steps;i++){const t=i/steps,b=lerpPoint(pts[0],pts[1],t),u=lerpPoint(pts[3],pts[2],t); ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(u.x,u.y); ctx.stroke();}
  ctx.strokeStyle='rgba(255,255,255,.98)'; ctx.lineWidth=5*dpr; ctx.beginPath(); ctx.moveTo(pts[3].x,pts[3].y); ctx.lineTo(pts[2].x,pts[2].y); ctx.stroke();
  ctx.restore();
  const poleOffset=0.35;
  const Lb={x:0,y:-COURT_H/2-poleOffset,z:0}, Lt={x:0,y:-COURT_H/2-poleOffset,z:NET_H};
  const Rb={x:0,y: COURT_H/2+poleOffset,z:0}, Rt={x:0,y: COURT_H/2+poleOffset,z:NET_H};
  drawPole(Lb,Lt,POLE_RADIUS,cam,f,sx,sy,dpr); drawPole(Rb,Rt,POLE_RADIUS,cam,f,sx,sy,dpr);
}
function lerpPoint(a,b,t){return {x:a.x+(b.x-a.x)*t,y:a.y+(b.y-a.y)*t}}
function drawPole(base,top,radius,cam,f,sx,sy,dpr){
  const b=projectCam(worldToCam(base,cam),f), t=projectCam(worldToCam(top,cam),f);
  const avgW=(b.z>0&&t.z>0)?((f/b.z+f/t.z)/2):(f/Math.max(b.z,1e-6)); const pxR=Math.max(2*dpr, radius*avgW);
  ctx.save(); ctx.strokeStyle = '#FFFFFF'; ctx.lineWidth=pxR*2; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(sx+b.x, sy-b.y); ctx.lineTo(sx+t.x, sy-t.y); ctx.stroke();
  ctx.lineWidth=Math.max(2*dpr, pxR*0.9); ctx.beginPath(); ctx.moveTo(sx+t.x-pxR*0.6, sy-t.y); ctx.lineTo(sx+t.x+pxR*0.6, sy-t.y); ctx.stroke(); ctx.restore();
}

/***** Heatmap con % *****/
function drawHeatmap(countsHalf, cam, f, sx, sy, dpr){
  if (!introFinished) return;
  const cLow=getComputedStyle(document.documentElement).getPropertyValue('--heat-low').trim();
  const cMid=getComputedStyle(document.documentElement).getPropertyValue('--heat-mid').trim();
  const cHigh=getComputedStyle(document.documentElement).getPropertyValue('--heat-high').trim();
  const totHome=countsHalf.home.reduce((a,b)=>a+b,0), totAway=countsHalf.away.reduce((a,b)=>a+b,0);
  for(let r=0;r<3;r++){
    for(let c=0;c<2;c++){
      const u0=c/2,u1=(c+1)/2,v0=r/3,v1=(r+1)/3;
      const quadWorld=[{x:(u0-.5)*COURT_W,y:(v0-.5)*COURT_H,z:0},{x:(u1-.5)*COURT_W,y:(v0-.5)*COURT_H,z:0},{x:(u1-.5)*COURT_W,y:(v1-.5)*COURT_H,z:0},{x:(u0-.5)*COURT_W,y:(v1-.5)*COURT_H,z:0}];
      const P=quadWorld.map(pw=>{const pr=projectCam(worldToCam(pw,cam),f);return{x:sx+pr.x,y:sy-pr.y};});
      const zonesCol = (c===0) ? [1,2,3] : [3,2,1];
      const zone = zonesCol[r];
      const side = c===0 ? 'home' : 'away';
      const val=countsHalf[side][zone-1]||0; const tot=side==='home'?totHome:totAway; const tHeat=tot>0?Math.min(1,val/tot):0;
      const inset=2*dpr; const cx=(P[0].x+P[1].x+P[2].x+P[3].x)/4, cy=(P[0].y+P[1].y+P[2].y+P[3].y)/4;
      const Q=P.map(pt=>{const dx=pt.x-cx,dy=pt.y-cy,L=Math.hypot(dx,dy)||1;const k=L-inset;return {x:cx+dx*(k/L),y:cy+dy*(k/L)};});
      ctx.beginPath(); ctx.moveTo(Q[0].x,Q[0].y); for(let i=1;i<4;i++) ctx.lineTo(Q[i].x,Q[i].y); ctx.closePath();
      ctx.save(); ctx.globalAlpha *= (typeof heatFade==='number' ? heatFade : 1);
      ctx.fillStyle = mixHeat(cLow,cMid,cHigh,tHeat, side==='home'?0.88:0.82); ctx.fill(); ctx.restore();
      const pct = tot>0 ? Math.round((val/tot)*100) : 0;
      ctx.save(); ctx.globalAlpha *= (typeof heatFade==='number' ? heatFade : 1);
      ctx.font=`${Math.round(16*dpr)}px "Barlow Condensed", Inter, system-ui, Arial`;
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.shadowColor='rgba(0,0,0,.45)'; ctx.shadowBlur=6*dpr;
      ctx.strokeStyle='rgba(0,0,0,.65)'; ctx.lineWidth=2*dpr;
      ctx.fillStyle='rgba(255,255,255,.97)';
      const label = `${pct}%`;
      ctx.strokeText(label, cx, cy); ctx.fillText(label, cx, cy); ctx.restore();
    }
  }
}

/***** Etiquetas de equipos & banner (sin iconos extra) *****/
let introFinished = false;
function ordinalES(n){switch(Number(n)){case 1:return 'PRIMER';case 2:return 'SEGUNDO';case 3:return 'TERCER';case 4:return 'CUARTO';case 5:return 'QUINTO';default:return `${n}º`;} };
function drawSetBanner(frame, dpr){
  if (!introFinished) return;
  const setShown = effectiveSet();
  const ord = ordinalES(setShown);
  const text = `${ord} SET · PORCENTAJE DE ATAQUES Y PUNTOS POR ZONA`;
  const x = frame.x + frame.w/2; const y = frame.y + frame.h - (TEAM_MARGIN * dpr) + 4*dpr;
  ctx.save();
  ctx.font = `${Math.round(BANNER_FS*dpr)}px "Barlow Condensed", Inter, system-ui, Arial`;
  ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
  ctx.shadowColor = 'rgba(0,0,0,.55)'; ctx.shadowBlur = 6*dpr;
  ctx.strokeStyle = 'rgba(14,165,255,.6)'; ctx.lineWidth = BANNER_STROKE * dpr;
  ctx.fillStyle   = BANNER_COLOR;
  ctx.strokeText(text, x, y); ctx.fillText(text, x, y);
  ctx.restore();
}

function drawTeamLabelsLR(frame, dpr){
  if (!introFinished) return;
  const margin = TEAM_MARGIN * dpr;
  const y = frame.y + margin + 12*dpr; // anchor line for vertical center
  const cxHome = frame.x + frame.w * 0.25;
  const cxAway = frame.x + frame.w * 0.75;

  ctx.save();
  ctx.font = `${Math.round(TEAM_FS*dpr)}px "Barlow Condensed", Inter, system-ui, Arial`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle'; // vertical centering

  // Style for pill
  const padX = 14*dpr, padY = 8*dpr;
  const shadowBlur = 6*dpr;

  function pillWithText(x, text){
    if(!text) return;
    const w = ctx.measureText(text).width;
    const h = Math.round(TEAM_FS*dpr*1.10);
    const px = x - w/2 - padX;
    const py = y - (h/2 + padY);
    const pw = w + padX*2;
    const ph = h + padY*2;
    const r = Math.min(999*dpr, ph/2);

    // gradient red (FIVB-style)
    const grd = ctx.createLinearGradient(px, py, px, py+ph);
    grd.addColorStop(0, '#E04662');
    grd.addColorStop(0.6, '#C93B57');
    grd.addColorStop(1, '#B2334A');

    // pill
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(px+r, py);
    ctx.arcTo(px+pw, py,   px+pw, py+ph, r);
    ctx.arcTo(px+pw, py+ph,px,    py+ph, r);
    ctx.arcTo(px,    py+ph,px,    py,    r);
    ctx.arcTo(px,    py,   px+pw, py,    r);
    ctx.closePath();
    ctx.fillStyle = grd;
    ctx.shadowColor = 'rgba(0,0,0,.45)';
    ctx.shadowBlur = shadowBlur;
    ctx.fill();
    // subtle inner stroke
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = 1*dpr;
    ctx.stroke();

    // text (centered exactly on y)
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(text, x, y);
    ctx.restore();
  }

  if (TEAM_AWAY){ pillWithText(cxHome, TEAM_AWAY.toUpperCase()); }
  if (TEAM_HOME){ pillWithText(cxAway, TEAM_HOME.toUpperCase()); }

  ctx.restore();
}


/***** Render principal *****/
let lastAgg={countsHalf:{home:[0,0,0],away:[0,0,0]}};
function drawScene(countsHalf){
  const dpr=Math.max(1,window.devicePixelRatio||1), w=canvas.clientWidth*dpr, h=canvas.clientHeight*dpr;
  canvas.width=w; canvas.height=h; ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,w,h);
  const eye=eyeFromParams(), cam=lookAt(eye,{x:0,y:0,z:0}); const f0=(h/2)/Math.tan((FOV*Math.PI/180)/2), pad=PADPX*dpr;
  const f=FIT?computeFitFocal(cam,w,h,f0,pad):f0;
  const rectProj=[{x:-COURT_W/2,y:COURT_H/2,z:0},{x: COURT_W/2,y:COURT_H/2,z:0},{x: COURT_W/2,y:-COURT_H/2,z:0},{x:-COURT_W/2,y:-COURT_H/2,z:0}].map(p=>projectCam(worldToCam(p,cam),f));
  let cx=0,cy=0; rectProj.forEach(q=>{cx+=q.x;cy+=q.y;}); cx/=4; cy/=4; const sx=w/2-cx, sy=h/2+cy;
  const poly=rectProj.map(q=>({x:sx+q.x,y:sy-q.y}));
  const frame = drawContainerFrame(poly, dpr);
  drawCourtPrism(cam,f,sx,sy,dpr);
  const topY=Math.min(poly[0].y,poly[1].y), botY=Math.max(poly[2].y,poly[3].y);
  const grad=courtGradient(ctx,topY,botY);
  ctx.fillStyle=grad; ctx.beginPath(); ctx.moveTo(poly[0].x,poly[0].y); for(let i=1;i<4;i++) ctx.lineTo(poly[i].x,poly[i].y); ctx.closePath(); ctx.fill();
  ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--line').trim()||'#fff'; ctx.lineWidth = 5*dpr; ctx.beginPath(); ctx.moveTo(poly[0].x,poly[0].y); for(let i=1;i<4;i++) ctx.lineTo(poly[i].x,poly[i].y); ctx.closePath(); ctx.stroke();
  drawCourtLines(cam,f,sx,sy,dpr);
  drawHeatmap(countsHalf,cam,f,sx,sy,dpr);
  drawTeamLabelsLR(frame, dpr);
  drawSetBanner(frame, dpr);
  drawNetWithPosts(cam,f,sx,sy,dpr);
}
function render(){ lastAgg = aggregateFromFirebase(); drawScene(lastAgg.countsHalf); }
function rerender(){ drawScene(lastAgg.countsHalf); }

/***** Resize *****/
new ResizeObserver(()=>rerender()).observe(document.querySelector('.stage'));

/***** Intro cam + fade *****/
function startHeatFade(){ if (heatFadeStarted) return; heatFadeStarted = true; const t0=performance.now(); function step(now){ const e=HEAT_MS>0?Math.min(1,(now-t0)/HEAT_MS):1; heatFade=e; rerender(); if(e<1) requestAnimationFrame(step);} requestAnimationFrame(step); }
function animateIntroCamera(){
  introFinished = false;
  const startYaw=44, endYaw=89; const duration=2500; const t0=performance.now(); const ease=t=>t<.5?4*t*t*t:1-Math.pow(-2*t+2,3)/2;
  function step(now){ const raw=(now-t0)/duration, t=Math.max(0,Math.min(1,raw)), e=ease(t); YAW_DEG=startYaw+(endYaw-startYaw)*e; rerender(); if(t<1) requestAnimationFrame(step); else { introFinished = true; if (!heatFadeStarted) startHeatFade(); rerender(); } }
  requestAnimationFrame(step);
}

/***** Teclado (solo cámara básica, sin HUD) *****/
window.addEventListener('keydown',(e)=>{
  const k=e.key;
  if (k==='ArrowLeft'){YAW_DEG=wrapDeg(YAW_DEG-3); rerender(); e.preventDefault();}
  if (k==='ArrowRight'){YAW_DEG=wrapDeg(YAW_DEG+3); rerender(); e.preventDefault();}
  if (k==='z'||k==='Z'){DIST=clamp(DIST-0.5,4,40); rerender();}
  if (k==='x'||k==='X'){DIST=clamp(DIST+0.5,4,40); rerender();}
  if (k==='m'||k==='M'){FOV=clamp(FOV-1,30,90); rerender();}
  if (k==='n'||k==='N'){FOV=clamp(FOV+1,30,90); rerender();}
});

/***** Carga inicial *****/
render();
animateIntroCamera();
</script>
</body>
</html>
